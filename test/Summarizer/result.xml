<doc>
	<about>
		<title>Using the Web Instead of a Window System</title>
		<authors>
			<author email="author1@example.com" name="author1" organization="MIT" />
			<author email="author2@example.com" name="author2" organization="CMU" />
		</authors>
	</about>
	<section name="Abstract">
		<line img="" ref="">We show how to deliver a sophisticated, yet intuitive, interactive application over the web using off-the-shelf web browsers as the interaction medium.</line>
		<line img="" ref="">This attracts a large user community, improves the rate of user acceptance, and avoids many of the pitfalls of software distribution.</line>
		<line img="" ref="">Web delivery imposes a novel set of constraints on user interface design.</line>
		<line img="" ref="">We outline the tradeoffs in this design space, motivate the choices necessary to deliver an application, and detail the lessons learned in the process.</line>
		<line img="" ref="">These issues are crucial because the growing popularity of the web guarantees that software delivery over the web will become ever more wide-spread.</line>
		<line img="" ref="">This application is publicly available at: http://www-ksl-svc.stanford.edu:5915/.</line>
	</section>
	<section name="Introduction">
		<line img="" ref="">This paper outlines our approach to providing a rich user interface to a sophisticated application over the web, specifies our design objectives, the constraints imposed by HTML and HTTP, and the trade-offs that we made in order to meet these objectives whilst satisfying these constraints.</line>
		<line img="" ref="">We further document the evolution of the design and implementation of our application, and some of the lessons learned.</line>
		<section name="The Application">
			<line img="" ref="">These properties of the user population motivate the development of distributed collaboration and the ontology editor tool.</line>
			<line img="" ref="">Feedback from users and data collected online support the claim that it is possible to deploy richly interactive applications over the web.</line>
			</section>
		<section name="Providing Access to Applications Over the Web">
			<line img="" ref="">We came to the web approach out of frustration with conventional approaches to software development and distribution.</line>
			<line img="" ref="">The costs of ensuring that software was portable over multiple hardware and software platforms together with the cost of distributing software releases, patches, and upgrades were simply too high for a small research institution.</line>
			</section>
		<section name="Other Web-Based Applications at the Ksl">
			<line img="" ref="6">A discussion of how this application was put on the web and of the design can be found in .</line>
			<line img="" ref="">Before the advent of web technologies, the DME system had a window-based interface that allowed the user to control the course of the simulation, and a hypertext browser that allowed the user to get explanations of the device's behavior.</line>
			</section>
	</section>
	<section name="Problem Analysis and Design">
		<line img="" ref="">In this section we begin to describe how we addressed the problem of delivering our network-based application, and how we designed it.</line>
		<section name="Objectives">
			<line img="" ref="">Once we had established our web-based system, our user community grew from a handful to hundreds in the space of a few months.</line>
			<line img="" ref="">Our burgeoning user community was an additional incentive to use the web.</line>
			<line img="" ref="">Furthermore, distributed access eliminates the need for our users to have high-end hardware systems or expensive licenses for the proprietary software systems that we used to develop our application more efficiently.</line>
			<line img="" ref="">Our challenge was to design a user interface that operates under the constraints of the web, remains intuitive and natural to users, and provides full access to the application.</line>
			<section name="Support for NaiVe Users">
				<line img="" ref="">HTML used for documentation: Our application has no manual at all per se.</line>
				<line img="" ref="">In-context, automatically-generated help: Unlike applications such as Microsoft Word 6.0, in which documentation is available only in an idiosyncratic hypertext browser, our application uses the same hypertext browser uniformly for all of its interface.</line>
				<line img="" ref="">Familiar interface: There was no existing interface metaphor for ontology editing.</line>
				<line img="" ref="">We selected a document metaphor (as opposed to a two dimensional representation as a directed graph, for example) so that the application could be smoothly integrated into the HTML world.</line>
				</section>
			<section name="Support for Power Users">
				<line img="" ref="">Although we were keen to expand our user community as much as possible, we were aware that experienced ontology developers would not want to be held back by an interface that was optimized for naive users.</line>
				<line img="" ref="">It is very important to us to support power users.</line>
				<line img="" ref="">The issue of power user support was eventually resolved by providing a powerful user preference facility.</line>
				<line img="" ref="">This allows the experienced user to tailor the look and feel as well as the set of commands exposed at any given time.</line>
			</section>
			<section name="User Support">
				<line img="" ref="">In order to be responsive to our users, we wanted to provide an obvious mechanism that they could use to make suggestions and report bugs.</line>
				<line img="" ref="">We resolved this by providing feedback buttons on every page for comments, questions and bug reports.</line>
				<line img="" ref="">The application captures the user's context automatically so as to make the user's bug report as useful to the developers as possible.</line>
			</section>
			<section name="Trustworthiness">
				<line img="" ref="">Because we were intending to provide a multi-user shared resource, it was essential for the user community to find our application both reliable and trustworthy.</line>
				<line img="" ref="">To this end, our application supports a user and group model similar to that provided by operating systems and password protection to ensure privacy and security.</line>
				<line img="" ref="">Ontologies are protected by maintaining multiple versions to which the user can revert if necessary.</line>
				<line img="" ref="">A sophisticated compare facility, which compares semantic units rather than text, allows the user to see exactly what has changed; an analysis facility tells the user what ought to be changed.</line>
			</section>
			<section name="Overcome Previous Difficulties">
				<line img="" ref="">There are a number of possible ways to deliver applications to a user community.</line>
				<line img="" ref="">We simply could not build a "PC-only", or "SUN/OS-only" application.</line>
				<line img="" ref="">Our new approach of keeping control of the software, and shipping a network service seemed the best way for us to overcome the difficulties of shipping software, while being able to impact a wide user community.</line>
				<line img="" ref="">Note: this figure is very wide and might require horizontal scrolling to see the right-hand part of the figure.</line>
				</section>
		</section>
		<section name="Constraints Imposed by Html and Http">
			<line img="" ref="">Selecting an anchor transmits a request to follow a hypertext link.</line>
			<line img="" ref="">In effect, an HTML interface can allow the user to apply a number of different commands to a single object, or a single command to a one of a number of different objects.</line>
			<line img="" ref="">Consequently, it is currently impossible to implement many features of sophisticated user interfaces over the web.</line>
			<line img="" ref="">This has many advantages for browsing hypertext documents, but it proves awkward for interface design.</line>
			<section name="Multiple Browsers">
				<line img="" ref="">A growing number of web browsers from a variety of institutions and vendors make non-standard extensions to the published protocols.</line>
				<line img="" ref="">These browsers provide different levels of support for features in the protocols.</line>
				<line img="" ref="">Fortunately, the protocol provides a means for browsers to identify themselves (although they do not describe their capabilities in a meaningful way), which allows servers such as ours to be sensitive to some of the distinctions between them.</line>
			</section>
			<section name="Time-Travel in the Interface">
				<line img="" ref="">A unique feature of web browsers is that they cache previously seen pages and allow the user to revisit these cached pages without notifying the server.</line>
				<line img="" ref="">In interactive applications delivered on the web, these "previously seen pages" can represent earlier states in a dialog with the user.</line>
				<line img="" ref="">If the user selects the deleted object as represented on that page, the application should either undo the deletion or report an error in a graceful way.</line>
				<line img="" ref="">Our application chooses the latter approach.</line>
			</section>
		</section>
		<section name="Choices and Design Principles">
			<line img="" ref="8">The underlying principle of our design was to minimize the cognitive load on the user imposed by the interface .</line>
			<line img="" ref="">As we worked within the constraints of HTML and HTTP to meet our objectives, we used this principle to guide our design decisions.</line>
			<line img="" ref="">The steps we took included: minimizing the number of intermediate states in complex command execution, minimizing the number of distinct types of pages, the number of distinct widgets, working to achieve consistent appearance across browsers, but working within the widgets provided by the native window systems.</line>
			<line img="" ref="">In this section we discuss these issues in more detail.</line>
			<section name="Minimize Intermediate Pages and Number of Clicks">
				<line img="" ref="">Because we want to minimize the number of clicks that a user performs, we are inclined to make pages richer (and potentially more confusing) to a user.</line>
				<line img="" ref="">Our application consists of the display and editing of a hierarchy of objects; classes exist within ontologies, classes have slots (attributes), and those slots can themselves have facets (attributes of attributes).</line>
				<line img="" ref="">A user can therefore edit a facet value directly on a class without going through any intermediate pages.</line>
				<line img="" ref="">The user is presented with considerably more information than may be of interest, and the user is more likely to have to scroll in order to see what is of interest.</line>
			</section>
			<section name="Edit-In-Place Metaphor">
				<line img="" ref="">In order to minimize the number of different-looking pages to which the user would be exposed, we decided that the editing environment should look as much like the browsing environment as possible.</line>
				<line img="" ref="">This is natural in our application, because even when a user is creating new objects, most of a user's work is browsing.</line>
				<line img="" ref="12">We preserve the browsing environment's look and feel by inserting edit widgets into the flow of the HTML page (see figures 2 and 3) in a manner similar to the protoTextExpando widget in the Newton user interface .</line>
				<line img="" ref="">An example of this insertion of edit widgets into the flow of the HTML page can be found here in the middle of the worked example.</line>
			</section>
			<section name="Pages Represent Objects">
				<line img="" ref="">A page was to be a representation of a specific object.</line>
				<line img="" ref="">This meant that commands on the menu bar would implicitly apply to the underlying objects which may be nested (e.g., an attribute of a class in an ontology.) Commands applicable to all of these may appear on the menu bar.</line>
			</section>
			<section name="Five Types of Interface Widgets">
				<line img="" ref="">We decided that in the normal course of events the user should be exposed to the minimal number of distinct widgets.</line>
				<line img="" ref="">The final design includes only five types of widgets (see section 3.2).</line>
			</section>
			<section name="Consistency Across Browsers">
				<line img="" ref="">We wanted our user interface to work in the same way across all platforms and browsers.</line>
				<line img="" ref="">One significant exception to this decision is HTML tables, which provide a much better way to present tabulated information than is otherwise possible.</line>
				<line img="" ref="13">We use HTML tables when communicating with a Netscape browser  and use PREformatted text (a fixed-width font display mode) for other browsers.</line>
				<line img="" ref="">Some user interfaces on the web are almost unusable without using Netscape.</line>
				</section>
			<section name="Native Window System'S Submit Buttons">
				<line img="" ref="">Many developers choose to exercise artistic control over the look and feel of their web pages by using custom bitmapped graphics for buttons instead of the native look and feel that the web browsers provide.</line>
				<line img="" ref="">In contrast, we chose to use the native window system's submit buttons for our interface.</line>
				<line img="" ref="">Our application was going to be complex enough without the user having to relearn what a button is supposed to look like.</line>
				<line img="" ref="">The constraint of supporting naive users meant that we could not allow any user interface tricks such as having extremely stylized icons that cause differing behavior depending on where on the icon the user clicks.</line>
				</section>
		</section>
	</section>
	<section name="Evolution of Design">
		<line img="" ref="">As we saw in the previous section, the design for our user interface was influenced both by a number of hard constraints imposed by our need to deliver our application over the web, and a number of design choices that reflected our beliefs about the usage patterns of our system and our prospective user community.</line>
		<line img="" ref="">In this section we describe the evolution of our design and our software, and show how we changed our user interface as we learned more about the application and received user feedback.</line>
		<line img="" ref="">One of the significant advantages of our implementation approach - a central server and standard browsers, coupled with a dynamic, rapid-prototyping implementation infrastructure - was that we could rapidly receive user feedback and introduce changes in response, often within a few minutes or hours.</line>
		<line img="" ref="">This meant that as soon as the server was established, our design progressed very rapidly.</line>
		<section name="Early Design and Mockup">
			<line img="" ref="">Our first step, therefore was to take pages of hypertext generated by this compilation process and manually edit them so as to mock up the editing interface.</line>
			<line img="" ref="">This process of developing mockups lasted about two weeks and went through multiple iterations, experimenting with different ways to handle the perceived problems of having a simple user interface that was nevertheless powerful.</line>
			<line img="" ref="">The whole mockup process was performed by editing these HTML files to refine the design.</line>
			<line img="" ref="">We addressed this problem by using a single intermediate page for edit operations, and by limiting the expressiveness of the user interface - we do not allow the user to execute all conceivably legal operations at any given point.</line>
			</section>
		<section name="Early Implementation">
			<line img="" ref="">Although we went to considerable effort to make the user interface clear and intuitive, it was still novel in many ways.</line>
			<line img="" ref="">Our user interface mockups had focused exclusively on the different ways to edit objects in the system - they completely neglected the sorts of operations that are typically found on the "File" menu of a normal user interface.</line>
			<line img="" ref="">Users connect to our application from all around the world from sites with widely differing quality of network connectivity.</line>
			<line img="" ref="">By default, we choose to hide this fact from users in order to simplify the appearance of the user interface.</line>
			</section>
		<section name="Problems of Scale">
			<line img="" ref="">By the time the system had reached this level of sophistication, we had made our application available to the public, and around one hundred users had tried it out.</line>
			<line img="" ref="">We found that however hard we might try, our application always produced pages that were multiple screens in height.</line>
			<line img="" ref="">Consequently, we replicated the menu bar at the bottom of the page so that the user could scroll to the nearest end of the document in order to select one of these more global commands.</line>
			<line img="" ref="">User feedback has caused us to spend more effort on displaying large ontologies.</line>
			</section>
		<section name="Breakdown of the Edit-In-Place Model">
			<line img="" ref="">When the user selected a creation operation, we presented the user with a fake page representing an object of the type being created, with a text widget into which the user could enter the new object's name.</line>
			<line img="" ref="">Another problem with the edit-in-place model of interaction is that HTML and HTTP give no effective control over viewport positioning.</line>
			<line img="" ref="">This means that when the user selects an edit operation, we have no choice but to refresh the whole page (unlike a more tightly-coupled user interface in which the system might push existing text aside in order to make room for the edit widgets).</line>
			<line img="" ref="">Furthermore, our application typically generates HTML pages more than one screen high.</line>
		</section>
		<section name="Observations on User Interaction">
			<line img="" ref="">We have conducted one informal email survey of our users and have collected over 1500 in-context comments and bug reports.</line>
			<line img="" ref="">Together with informal observation of local users, we have observed several surprising characteristics of system usage.</line>
			<section name="Reluctance to Click">
				<line img="" ref="">We have noticed that users are reluctant to experiment freely within the application.</line>
				<line img="" ref="">Some browsers are difficult to interrupt if an address is not well formed, a server refuses to respond or responds slowly, or if a large document is transmitted.</line>
				<line img="" ref="">Many web-based applications are brittle and crash unexpectedly.</line>
				<line img="" ref="">It would be interesting to find out why users are so reluctant to experiment, since this could have significant impact on the design of networked application user interfaces if this behavior proved to be widespread.</line>
			</section>
			<section name="Logging Out">
				<line img="" ref="">We have observed that our users have a powerful desire to be able to log out of our system.</line>
				<line img="" ref="">Because a user's connection with our application lasts only as long as each individual request from the browser - typically only a second or two - and because the user could walk away, leaving the browser at any time - we have had to engineer the system so that logging out is not necessary.</line>
				<line img="" ref="">The system has a set of timeouts and defaults that allow it to recover quiescent resources.</line>
				<line img="" ref="">We have therefore provided a command to give the user the illusion of logging out.</line>
			</section>
			<section name="The Usage of User Preferences">
				<line img="" ref="">If we look at active users, whom we define as those who have executed at least 50 commands, we find that some 41% of our users have changed at least one preference.</line>
				<line img="7" ref="">Figure 5 plots the distribution of the number preferences modified against the number of requests performed by each user.</line>
				<line img="" ref="">Some preferences have been modified by only one user, one has been set by 47 users.</line>
				<line img="7" ref="">Figure 5. The average number of preference variables set by each user plotted against the total number of non-trivial requests made by each user to our server.</line>
				</section>
		</section>
	</section>
	<section name="The Future">
		<line img="" ref="">The web is an ever-changing medium, and both the technology and standards are advancing very rapidly.</line>
		<line img="" ref="">We must therefore consider what we would do (or would have done) if Java or some similarly capable remote scripting facility were to be reliable and powerful enough to use for our application.</line>
		<line img="" ref="">Certainly, had Java been ready for serious use a year ago we would have been very tempted to use it to get around some of the severe constraints of HTML.</line>
		<line img="" ref="">In this section, we detail some of the issues surrounding the use of client-side applets, and we then enumerate some of the simple changes that could be made to HTML to make this sort of application much easier and better.</line>
		<section name="Java and Client-Side Scripting">
			<line img="" ref="">Using Java would allow one to circumvent a number of the constraints in the widget set that HTML imposes.</line>
			<line img="" ref="">It would have to be supported by a wide variety of browsers, from Netscape and NetCruiser to Lynx.</line>
			<line img="" ref="">If we were to make Java an important part of our application, we would either exclude such users or we would have to support both plain HTML interaction and Java as well, which would result in a duplication of effort, and increased development and maintenance costs.</line>
			<line img="" ref="">Moreover, the ephemeral connections of HTML/HTTP provide a certain degree of resiliency that would be lost by the need to keep open persistent network connections over possibly unreliable networks.</line>
		</section>
		<section name="Html: Problems and Solutions">
			<line img="" ref="">Selecting one of these options would take the user to red.html, green.html, or blue.html respectively.</line>
			<line img="" ref="">A major problem with delivering a complex application over the web is that almost everything on the page is anchored.</line>
			<line img="" ref="">This means that the size of the document that is actually transmitted to the user in bytes is typically very much larger than would be expected for a document of that apparent size.</line>
			<line img="" ref="">This could greatly compress the HTML generated by a complex application.</line>
			</section>
	</section>
	<section name="Conclusions">
		<line img="" ref="">We have shown how we were able to deliver a sophisticated, yet intuitive, interactive application as a network service.</line>
		<line img="" ref="">An off-the-shelf web browser provides the user's interaction medium.</line>
		<line img="" ref="">The key contribution of this paper is to describe the constraints imposed on user interface design by this interaction medium, outline the tradeoffs in this design space, and motivate the choices we made in order to deliver our application over the web.</line>
		</section>
	<section name="Acknowledgments">
		<line img="" ref="">The authors gratefully acknowledge the support of the following funding agencies: NASA Ames Research Center under contract NCC2-537, ARPA and NASA/ARC under contract NAG2-581 (ARPA order 8607), and CommerceNet under contract CN-1094 (TRP #F33615-94-4413).</line>
		<line img="" ref="">Numerous people in our user community were both influential and helpful in the development of this application, particularly Wanda Pratt, Rupert Brauch, and Richard Fikes.</line>
	</section>
	<keywords>
		<keyword>Internet application</keyword>
		<keyword>remote user interface</keyword>
		<keyword>active document</keyword>
		<keyword>CSCW</keyword>
		<keyword>World Wide Web</keyword>
		<keyword>Hypertext</keyword>
		<keyword>HTML</keyword>
		<keyword>HTTP</keyword>
		<keyword>Java</keyword>
	</keywords>
	<images>
		<image alt="Figure 1" caption="Figure 1. The final design (left) used a row of icons (top) for important or frequently used operations, and pop-up menus preceeded by submit buttons (e.g., &quot;File&quot; top left) as labels. Selecting the `?' help command (top center left) takes the user to a page explaining all applicable commands, and with a labeled explanation of the page (right). The command widgets on the help page are real. Selecting one of these widgets will execute the command in the context of the page that the user was on. Tears in the figure elide material extraneous to this discussion. Note: this figure is very wide and might require horizontal scrolling to see the right-hand part of the figure. A slide show examplifying the Help feature can be found here. 2.2. Constraints Imposed by HTML and HTTP There are only two ways for the browser to transmit information to the server (i.e., the application). Selecting an anchor transmits a request to follow a hypertext link. Pressing a submit button transmits the widget state. Until a submit button is pushed, it is not possible for the server to determine anything about intermediate activities that a user might perform such as typing text into an input field, toggling radio buttons or check boxes, selecting items from menus, moving the mouse, and so on." id="1" src="jpr_fg18.gif" />
		<image alt="Figure 2" caption="Figure 2. In early designs, radio buttons were used to select an argument (left). Selecting an operation from a pop-up menu and clicking on a submit button (top left) inserted suitable edit widgets into the flow of the page at the selected location (right). A slide show of the actual mockup HTML pages can be found here. 2.2.1. Multiple Browsers A growing number of web browsers from a variety of institutions and vendors make non-standard extensions to the published protocols. These browsers provide different levels of support for features in the protocols. Fortunately, the protocol provides a means for browsers to identify themselves (although they do not describe their capabilities in a meaningful way), which allows servers such as ours to be sensitive to some of the distinctions between them." id="2" src="jpr_fg19.gif" />
		<image alt="" caption="" id="3" src="jpr_fg20.gif" />
		<image alt="" caption="" id="4" src="jpr_fg21.gif" />
		<image alt="Figure 3" caption="Figure 3. The final version uses edit widgets in front of all editable objects, and &quot;+&quot; widgets wherever an addition is possible (left). In this example, we show editing the Slot-Value-Type facet value of Thesis.University from Institution to University. Selecting an edit pencil inserts the necessary widgets to elicit or modify the value in context (middle). The user has entered University instead of Institution. The user can remove screen clutter by inhibiting all edit widgets (right). Here is a detailed worked example of an editing session using the ontology editor, showing a number of the features of the editor." id="5" src="jpr_fg22.gif" />
		<image alt="Figure 4" caption="Figure 4. The hierarchical class browser shows large graphs of objects in a compact form. Triangular widgets open and close subgraphs. &quot;Focus&quot; widgets move the selected object to the root of the displayed tree." id="6" src="jpr_fg25.gif" />
		<image alt="Figure 5" caption="Figure 5. The average number of preference variables set by each user plotted against the total number of non-trivial requests made by each user to our server" id="7" src="jpr_fg26.gif" />
		<image alt="" caption="" id="8" src="jpr_fg06.gif" />
	</images>
	<references>
		<reference id="1">1</reference>
		<reference id="2">Farquhar, A, Fikes, R, Pratt, W, and Rice, J. Collaborative Ontology Construction for Information Integration. Technical Report KSL-95-63, Stanford University, Knowledge Systems Laboratory. 1995</reference>
		<reference id="3">2</reference>
		<reference id="4">Fikes, R., Cutkosky, M., Gruber, T., &amp; van Baalen, J. Knowledge Sharing Technology Project Overview. Technical Report KSL 91-71, Stanford University, Knowledge Systems Laboratory. 1991</reference>
		<reference id="5">3</reference>
		<reference id="6">Gruber, T. R. A Translation Approach to Portable Ontology Specifications. Knowledge Acquisition, 5(2), 199-220. 1993</reference>
		<reference id="7">4</reference>
		<reference id="8">Gruber, T., and Gautier, P. Machine-generated Explanations of Engineering Models: A compositional modeling approach. Proceedings of the 13th International Joint Conference on Artificial Intelligence, Chambery, France, 1502-1508. Knowledge Systems Laboratory. 1993.</reference>
		<reference id="9">5</reference>
		<reference id="10">Gruber, T., and Olsen, G. An ontology for engineering mathematics. In Jon Doyle, Piero Torasso, &amp; Erik Sandewall, Ed., Fourth International Conference on Principles of Knowledge Representation and Reasoning, Gustav Stresemann Institut, Bonn, Germany, Morgan Kaufmann, 1994.</reference>
		<reference id="11">6</reference>
		<reference id="12">Gruber, T., Vemuri, S, and Rice, J. Model-based Virtual Document Generation. Technical Report KSL-95-80 (this is a hypertext paper best viewed here), Stanford University, Knowledge Systems Laboratory. 1995</reference>
		<reference id="13">7</reference>
		<reference id="14">Grudin, J. Groupware and Cooperative Work: Problems and Prospects, in The Art of Human-Computer Interface Design. Laurel, B., Ed. Addison-Wesley Publishing Company, Inc., Reading, Massachusetts, 1990, pp. 171-185.</reference>
		<reference id="15">8</reference>
		<reference id="16">Gygi, K. Recognizing the Symptoms of Hypertext... and What to do About it, in Laurel, B., ed., The Art of Human-Computer Interface Design. Addison-Wesley Publishing Company, Inc., Reading, Massachusetts, 1990, pp. 279-287.</reference>
		<reference id="17">9</reference>
		<reference id="18">Knowledge Sharing Technology Project. http://www-ksl.stanford.edu/kst/kst-overview.html</reference>
		<reference id="19">10</reference>
		<reference id="20">Lamping, J, Rao, R, Pirolli, P: A Focus+Context Technique Based on Hyperbolic Geometry for Visualizing Large Hierarchies. In CHI '95 Human Factors in Computing Systems. 1995. New York: ACM Press.</reference>
		<reference id="21">11</reference>
		<reference id="22">Marshall C., and Irish P. Guided tours and On-Line Presentations: How Authors Make Existing Hypertext Intelligible for Readers. Proceedings ACM Hypertext'89. Pitsburgh, PA, USA, 5-8 November 1989. ACM Press 1989.</reference>
		<reference id="23">12</reference>
		<reference id="24">Newton Programmers Guide. Apple Computer Inc. Cupertino CA. 1993</reference>
		<reference id="25">13</reference>
		<reference id="26">Netscape Navigator Handbook, Netscape Communications Corporation, Mountain View, California. Also available on the world wide web at: http://home.netscape.com/eng/mozilla/1.1/handbook/</reference>
		<reference id="27">14</reference>
		<reference id="28">Sukaviriya S, and Foley J. Coupling A UI Framework with Automatic Generation of Context-Sensitive Animated Help, Proceedings ACM UIST'90 (User Interface Software and Technology), Snowbird, Utah. October 3-5 1990. 152-166 ACM Press 1990</reference>
		<reference id="29">15</reference>
		<reference id="30">Trigg, R. Guided tours and tabletops: tools for communicating in a hypertext environment. ACM Trans. Office Info. Syst. 6, 4, October 1988, 398-414.</reference>
		<reference id="31">16</reference>
		<reference id="32">World Wide Web Consortium. http://www.w3.org/</reference>
	</references>
</doc>